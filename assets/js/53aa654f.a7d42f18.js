"use strict";(self.webpackChunksquirrels_docs=self.webpackChunksquirrels_docs||[]).push([[4531],{8:(e,t,s)=>{s.r(t),s.d(t,{assets:()=>c,contentTitle:()=>o,default:()=>h,frontMatter:()=>a,metadata:()=>r,toc:()=>l});var n=s(5893),i=s(1151);const a={sidebar_position:2},o="Best Practices",r={id:"client/best-practices",title:"Best Practices",description:"The API consumers can often make assumptions on how Squirrels APIs may change across versions (see Versioning Best Practices for details). Likewise, the API builders can often make certain assumptions on how API consumers would interact with the API results. The following are some of these assumptions.",source:"@site/docs/client/best-practices.md",sourceDirName:"client",slug:"/client/best-practices",permalink:"/docs/client/best-practices",draft:!1,unlisted:!1,tags:[],version:"current",sidebarPosition:2,frontMatter:{sidebar_position:2},sidebar:"tutorialSidebar",previous:{title:"REST API Types",permalink:"/docs/client/rest-api"},next:{title:"Python APIs",permalink:"/docs/category/python-apis"}},c={},l=[{value:"Referencing a Dataset Column",id:"referencing-a-dataset-column",level:3},{value:"Loading Results to a Fixed Schema",id:"loading-results-to-a-fixed-schema",level:3}];function d(e){const t={a:"a",h1:"h1",h3:"h3",li:"li",p:"p",ul:"ul",...(0,i.a)(),...e.components};return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsx)(t.h1,{id:"best-practices",children:"Best Practices"}),"\n",(0,n.jsxs)(t.p,{children:["The API consumers can often make assumptions on how Squirrels APIs may change across versions (see ",(0,n.jsx)(t.a,{href:"../tips/versioning",children:"Versioning Best Practices"})," for details). Likewise, the API builders can often make certain assumptions on how API consumers would interact with the API results. The following are some of these assumptions."]}),"\n",(0,n.jsx)(t.h3,{id:"referencing-a-dataset-column",children:"Referencing a Dataset Column"}),"\n",(0,n.jsx)(t.p,{children:"Whenever a column of the dataset result is referenced, it should be referenced by name rather than by position / index. Thus, when a new column is added to the dataset before an existing column, the reference to that existing column would not break."}),"\n",(0,n.jsx)(t.h3,{id:"loading-results-to-a-fixed-schema",children:"Loading Results to a Fixed Schema"}),"\n",(0,n.jsx)(t.p,{children:"Sometimes, there could be situations where the columns coming from the dataset result API are loaded into a SQL database with a fixed schema. However, the dataset result may change the columns it has based on the parameter selections provided. To maintain a robust load process, follow these rules:"}),"\n",(0,n.jsxs)(t.ul,{children:["\n",(0,n.jsx)(t.li,{children:"If the column exists in the SQL database schema but not the API result, load nulls to that column in the SQL database table"}),"\n",(0,n.jsx)(t.li,{children:"If the column does not exist in the SQL database schema but exists in the API result, ignore that column in the API result"}),"\n",(0,n.jsx)(t.li,{children:'Suppose that the "group by" dimension of a dataset changes based on a parameter. Since the dataset result API response provides details on which columns are dimensions, you can use this information to dynamically change which is your i-th dimension (first, second, third, etc.), and load those columns to generic column names in the SQL database like "dimension1" instead matching the actual column name of the dimension.'}),"\n"]})]})}function h(e={}){const{wrapper:t}={...(0,i.a)(),...e.components};return t?(0,n.jsx)(t,{...e,children:(0,n.jsx)(d,{...e})}):d(e)}},1151:(e,t,s)=>{s.d(t,{Z:()=>r,a:()=>o});var n=s(7294);const i={},a=n.createContext(i);function o(e){const t=n.useContext(a);return n.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function r(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:o(e.components),n.createElement(a.Provider,{value:t},e.children)}}}]);